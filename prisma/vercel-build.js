/**
 * Special build script for Vercel deployment to handle problematic migrations
 * Optimized for Neon PostgreSQL
 */
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const MIGRATIONS_DIR = path.join(__dirname, 'migrations');
const IS_VERCEL = process.env.VERCEL === '1';

console.log('ğŸ”§ Running Vercel build script for Prisma with Neon PostgreSQL...');
console.log(`ğŸ” Environment: ${IS_VERCEL ? 'Vercel' : 'Local'}`);

try {
  // Ensure the DATABASE_URL environment variable is set
  if (!process.env.DATABASE_URL) {
    console.error('âŒ No DATABASE_URL found in environment');
    console.error('Please set the DATABASE_URL environment variable in Vercel project settings');
    process.exit(1);
  }

  // Verify the database URL is for PostgreSQL and potentially Neon
  if (!process.env.DATABASE_URL.includes('postgresql://')) {
    console.error('âŒ DATABASE_URL does not appear to be a PostgreSQL connection string');
    console.error('Please ensure your Neon PostgreSQL connection string is correctly formatted');
    process.exit(1);
  }

  console.log('âœ… DATABASE_URL is properly set');

  // Ensure the migrations directory exists
  if (!fs.existsSync(MIGRATIONS_DIR)) {
    fs.mkdirSync(MIGRATIONS_DIR, { recursive: true });
  }

  // Function to reset the migrations directory and create a fresh migration
  function resetMigrations() {
    console.log('ğŸ”„ Resetting migrations directory...');

    // Remove all existing migrations files
    if (fs.existsSync(MIGRATIONS_DIR)) {
      const migrationFiles = fs.readdirSync(MIGRATIONS_DIR)
        .filter(file => file !== 'migration_lock.toml');

      for (const file of migrationFiles) {
        const filePath = path.join(MIGRATIONS_DIR, file);
        if (fs.lstatSync(filePath).isDirectory()) {
          fs.rmSync(filePath, { recursive: true, force: true });
        } else if (file !== 'migration_lock.toml') {
          fs.unlinkSync(filePath);
        }
      }
    }

    // Ensure the migration_lock.toml file is correct
    console.log('ğŸ“ Creating migration lock file for PostgreSQL...');
    fs.writeFileSync(
      path.join(MIGRATIONS_DIR, 'migration_lock.toml'),
      '# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = "postgresql"\n'
    );

    // Create a fresh migration directory
    console.log('ğŸ“ Creating fresh PostgreSQL migration...');
    const timestamp = new Date().toISOString().replace(/[^0-9]/g, '').slice(0, 14);
    const newMigrationDir = path.join(MIGRATIONS_DIR, `${timestamp}_neon_init`);

    if (!fs.existsSync(newMigrationDir)) {
      fs.mkdirSync(newMigrationDir, { recursive: true });
    }

    // Write PostgreSQL-compatible migration that uses IF NOT EXISTS for safety
    fs.writeFileSync(
      path.join(newMigrationDir, 'migration.sql'),
      `-- CreateTable for Neon PostgreSQL
CREATE TABLE IF NOT EXISTS "Appointment" (
    "id" SERIAL PRIMARY KEY,
    "teaser" TEXT NOT NULL,
    "mainText" TEXT NOT NULL,
    "startDateTime" TIMESTAMP(3) NOT NULL,
    "endDateTime" TIMESTAMP(3),
    "street" TEXT,
    "city" TEXT,
    "state" TEXT,
    "postalCode" TEXT,
    "firstName" TEXT,
    "lastName" TEXT,
    "recurringText" TEXT,
    "fileUrls" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "processed" BOOLEAN NOT NULL DEFAULT false,
    "processingDate" TIMESTAMP(3)
);`
    );

    console.log('âœ… New migration created at', newMigrationDir);
    return newMigrationDir;
  }

  // Function to attempt a clean database reset on Vercel for Neon
  async function resetNeonDatabase() {
    try {
      console.log('ğŸ—‘ï¸ Attempting to reset Neon PostgreSQL database...');

      // For Neon, we can use their serverless driver or just Prisma itself
      // Since direct psql might not be available in the Vercel environment,
      // we'll use a different approach

      // First try to drop the schema using Prisma client
      try {
        // Create a temporary prisma schema to use for direct SQL execution
        const tempSchemaPath = path.join(__dirname, 'temp-schema.prisma');
        fs.writeFileSync(tempSchemaPath, `
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
generator client {
  provider = "prisma-client-js"
  output   = "./temp-client"
}
        `);

        console.log('ğŸ”§ Generating temporary Prisma client for reset...');
        execSync(`npx prisma generate --schema=${tempSchemaPath}`, { stdio: 'inherit' });

        // Create a temporary script to execute the SQL
        const resetScriptPath = path.join(__dirname, 'reset-script.js');
        fs.writeFileSync(resetScriptPath, `
const { PrismaClient } = require('./temp-client');
const prisma = new PrismaClient();

async function main() {
  try {
    // Drop public schema and recreate it
    await prisma.$executeRawUnsafe('DROP SCHEMA IF EXISTS public CASCADE');
    await prisma.$executeRawUnsafe('CREATE SCHEMA public');

    // Set appropriate privileges
    await prisma.$executeRawUnsafe('GRANT ALL ON SCHEMA public TO postgres');
    await prisma.$executeRawUnsafe('GRANT ALL ON SCHEMA public TO public');

    console.log('âœ… Database reset successful');
  } catch (error) {
    console.error('âŒ Failed to reset database:', error);
  } finally {
    await prisma.$disconnect();
  }
}

main();
        `);

        // Execute the reset script
        console.log('ğŸ”„ Executing database reset...');
        execSync(`node ${resetScriptPath}`, { stdio: 'inherit' });

        // Clean up temporary files
        try {
          fs.unlinkSync(tempSchemaPath);
          fs.unlinkSync(resetScriptPath);
          fs.rmSync(path.join(__dirname, 'temp-client'), { recursive: true, force: true });
        } catch (cleanupError) {
          console.warn('âš ï¸ Could not clean up temporary files:', cleanupError);
        }

        return true;
      } catch (resetError) {
        console.error('âŒ Failed to reset database using Prisma:', resetError);
        console.log('âš ï¸ Will attempt to continue with migration deployment');
        return false;
      }
    } catch (error) {
      console.error('âŒ Error during database reset attempt:', error);
      return false;
    }
  }

  // Main execution
  (async () => {
    // If in Vercel environment, try to reset the database
    if (IS_VERCEL) {
      console.log('ğŸ” Detected Vercel environment, attempting database reset...');
      await resetNeonDatabase();
    }

    // Always reset and recreate migrations to ensure consistency
    resetMigrations();

    // Generate Prisma client
    console.log('ğŸ”§ Generating Prisma client...');
    execSync('npx prisma generate', { stdio: 'inherit' });

    // Push the schema directly (safer with Neon as it's idempotent)
    console.log('ğŸš€ Pushing schema to database...');
    try {
      execSync('npx prisma db push --accept-data-loss', { stdio: 'inherit' });
      console.log('âœ… Schema push completed');
    } catch (pushError) {
      console.error('âŒ Schema push failed, falling back to migrate deploy:', pushError);

      // If push fails, try migrate deploy as fallback
      console.log('ğŸ”§ Attempting migrate deploy as fallback...');
      execSync('npx prisma migrate deploy', { stdio: 'inherit' });
    }

    console.log('âœ… Prisma setup with Neon PostgreSQL completed successfully!');
    process.exit(0);
  })();
} catch (error) {
  console.error('âŒ Error during Prisma setup for Vercel with Neon:', error);
  process.exit(1);
}